<?php

declare(strict_types=1);

/*
 * This file has been auto generated by Jane,
 *
 * Do no edit it directly.
 */

namespace Braze\Endpoint;

class GetContentBlocksList extends \Braze\Runtime\Client\BaseEndpoint implements \Braze\Runtime\Client\Endpoint
{
    use \Braze\Runtime\Client\EndpointTrait;

    /**
     * > Use this endpoint to list your existing [Content Blocks](https://www.braze.com/docs/user_guide/engagement_tools/templates_and_media/content_blocks/) information.
     *
     * ## Prerequisites
     *
     * To use this endpoint, youâ€™ll need an [API key](https://www.braze.com/docs/api/api_key/) with the `content_blocks.list` permission.
     *
     * ## Rate limit
     *
     * We apply the default Braze rate limit of 250,000 requests per hour to this endpoint, as documented in [API rate limits](https://www.braze.com/docs/api/api_limits/).
     *
     * ## Request parameters
     *
     * | Parameter | Required | Data Type | Description |
     * | --- | --- | --- | --- |
     * | `modified_after` | Optional | String in [ISO-8601](https://en.wikipedia.org/wiki/ISO_8601) format | Retrieve only Content Blocks updated at or after the given time. |
     * | `modified_before` | Optional | String in [ISO-8601](https://en.wikipedia.org/wiki/ISO_8601) format | Retrieve only Content Blocks updated at or before the given time. |
     * | `limit` | Optional | Positive Number | Maximum number of Content Blocks to retrieve. Default to 100 if not provided, with a maximum acceptable value of 1000. |
     * | `offset` | Optional | Positive Number | Number of Content Blocks to skip before returning rest of the templates that fit the search criteria. |
     *
     * ## Example request
     *
     * ``` json
     * curl --location --request GET 'https://rest.iad-01.braze.com/content_blocks/list?modified_after=2020-01-01T01:01:01.000000&modified_before=2020-02-01T01:01:01.000000&limit=100&offset=1' \
     * --header 'Authorization: Bearer YOUR-API-KEY-HERE'
     *
     *  ```
     *
     * ## Response
     *
     * ``` json
     * Content-Type: application/json
     * Authorization: Bearer YOUR_REST_API_KEY
     * {
     *   "count": "integer",
     *   "content_blocks": [
     *     {
     *       "content_block_id": (string) the Content Block identifier,
     *       "name": (string) the name of the Content Block,
     *       "content_type": (string) the content type, html or text,
     *       "liquid_tag": (string) the Liquid tags,
     *       "inclusion_count" : (integer) the inclusion count,
     *       "created_at": (string) The time the Content Block was created in ISO 8601,
     *       "last_edited": (string) The time the Content Block was last edited in ISO 8601,
     *       "tags": (array) An array of tags formatted as strings,
     *     }
     *   ]
     * }
     *
     *  ```
     *
     * ## Troubleshooting
     *
     * The following table lists possible returned errors and their associated troubleshooting steps.
     *
     * | Error | Troubleshooting |
     * | --- | --- |
     * | `Modified after time is invalid` | The provided date is not a valid or parsable date. Reformat this value as a string in ISO 8601 format (`yyyy-mm-ddThh:mm:ss.ffffff`). |
     * | `Modified before time is invalid` | The provided date is not a valid or parsable date. Reformat this value as a string in ISO 8601 format (`yyyy-mm-ddThh:mm:ss.ffffff`). |
     * | `Modified after time must be earlier than or the same as modified before time.` | Change the `modified_after` value to a time that is earlier than the `modified_before` time. |
     * | `Content Block number limit is invalid` | The `limit` parameter must be an integer (positive number) greater than 0. |
     * | `Content Block number limit must be greater than 0` | Change the `limit` parameter to an integer greater than 0. |
     * | `Content Block number limit exceeds maximum of 1000` | Change the `limit` parameter to an integer less than 1000. |
     * | `Offset is invalid` | The `offset` parameter must be an integer greater than 0. |
     * | Offset must be greater than 0 | Change the `offset` parameter to an integer greater than 0. |
     *
     * @param array $queryParameters {
     *
     * @var string $modified_after (Optional) String in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601)
     *
     * Retrieve only content blocks updated at or after the given time.
     * @var string $modified_before (Optional) String in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601)
     *
     * Retrieve only content blocks updated at or before the given time.
     * @var int $limit (Optional) Positive Number
     *
     * Maximum number of content blocks to retrieve. Default to 100 if not provided, with a maximum acceptable value of 1000.
     * @var int $offset (Optional) Positive Number
     *
     * Number of content blocks to skip before returning rest of the templates that fit the search criteria.
     * }
     *
     * @param array $headerParameters {
     *
     * @var string $Authorization
     *             }
     */
    public function __construct(array $queryParameters = [], array $headerParameters = [])
    {
        $this->queryParameters = $queryParameters;
        $this->headerParameters = $headerParameters;
    }

    public function getMethod(): string
    {
        return 'GET';
    }

    public function getUri(): string
    {
        return '/content_blocks/list';
    }

    public function getBody(\Symfony\Component\Serializer\SerializerInterface $serializer, $streamFactory = null): array
    {
        return [[], null];
    }

    public function getExtraHeaders(): array
    {
        return ['Accept' => ['application/json']];
    }

    protected function getQueryOptionsResolver(): \Symfony\Component\OptionsResolver\OptionsResolver
    {
        $optionsResolver = parent::getQueryOptionsResolver();
        $optionsResolver->setDefined(['modified_after', 'modified_before', 'limit', 'offset']);
        $optionsResolver->setRequired([]);
        $optionsResolver->setDefaults([]);
        $optionsResolver->addAllowedTypes('modified_after', ['string']);
        $optionsResolver->addAllowedTypes('modified_before', ['string']);
        $optionsResolver->addAllowedTypes('limit', ['int']);
        $optionsResolver->addAllowedTypes('offset', ['int']);

        return $optionsResolver;
    }

    protected function getHeadersOptionsResolver(): \Symfony\Component\OptionsResolver\OptionsResolver
    {
        $optionsResolver = parent::getHeadersOptionsResolver();
        $optionsResolver->setDefined(['Authorization']);
        $optionsResolver->setRequired([]);
        $optionsResolver->setDefaults([]);
        $optionsResolver->addAllowedTypes('Authorization', ['string']);

        return $optionsResolver;
    }

    /**
     * @return null
     *
     * @throws \Braze\Exception\GetContentBlocksListBadRequestException
     * @throws \Braze\Exception\GetContentBlocksListUnauthorizedException
     * @throws \Braze\Exception\GetContentBlocksListForbiddenException
     * @throws \Braze\Exception\GetContentBlocksListNotFoundException
     * @throws \Braze\Exception\GetContentBlocksListTooManyRequestsException
     * @throws \Braze\Exception\GetContentBlocksListInternalServerErrorException
     */
    protected function transformResponseBody(\Psr\Http\Message\ResponseInterface $response, \Symfony\Component\Serializer\SerializerInterface $serializer, ?string $contentType = null)
    {
        $status = $response->getStatusCode();
        $body = (string) $response->getBody();
        if (is_null($contentType) === false && (200 === $status && mb_strpos(strtolower($contentType), 'application/json') !== false)) {
            return json_decode($body);
        }
        if (is_null($contentType) === false && (400 === $status && mb_strpos(strtolower($contentType), 'application/json') !== false)) {
            throw new \Braze\Exception\GetContentBlocksListBadRequestException($serializer->deserialize($body, 'Braze\Model\Error', 'json'), $response);
        }
        if (is_null($contentType) === false && (401 === $status && mb_strpos(strtolower($contentType), 'application/json') !== false)) {
            throw new \Braze\Exception\GetContentBlocksListUnauthorizedException($serializer->deserialize($body, 'Braze\Model\Error', 'json'), $response);
        }
        if (is_null($contentType) === false && (403 === $status && mb_strpos(strtolower($contentType), 'application/json') !== false)) {
            throw new \Braze\Exception\GetContentBlocksListForbiddenException($serializer->deserialize($body, 'Braze\Model\Error', 'json'), $response);
        }
        if (is_null($contentType) === false && (404 === $status && mb_strpos(strtolower($contentType), 'application/json') !== false)) {
            throw new \Braze\Exception\GetContentBlocksListNotFoundException($serializer->deserialize($body, 'Braze\Model\Error', 'json'), $response);
        }
        if (is_null($contentType) === false && (429 === $status && mb_strpos(strtolower($contentType), 'application/json') !== false)) {
            throw new \Braze\Exception\GetContentBlocksListTooManyRequestsException($serializer->deserialize($body, 'Braze\Model\Error', 'json'), $response);
        }
        if (is_null($contentType) === false && (500 === $status && mb_strpos(strtolower($contentType), 'application/json') !== false)) {
            throw new \Braze\Exception\GetContentBlocksListInternalServerErrorException($serializer->deserialize($body, 'Braze\Model\Error', 'json'), $response);
        }
    }

    public function getAuthenticationScopes(): array
    {
        return ['BearerAuth'];
    }
}
